<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tennis Rally Trainer — Final Fixes</title>
<style>
  :root{--outer:#28a75a}
  html,body{height:100%;margin:0;background:radial-gradient(circle at top,#021123,#041428);font-family:Inter,system-ui,Arial;color:#fff;display:flex;flex-direction:column;align-items:center}
  h1{margin:14px 0 8px}
  #wrap{width:1100px;max-width:96vw;padding-bottom:20px;position:relative}
  canvas{display:block;width:100%;height:auto;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,0.6);background:transparent;border:8px solid var(--outer)}
  .controls{display:flex;gap:12px;justify-content:center;margin-top:10px}
  button{padding:10px 16px;border-radius:8px;border:none;background:#2fa66b;color:#fff;font-weight:700;cursor:pointer}
  button.stop{background:#e04848}
  .panel{display:flex;flex-wrap:wrap;gap:16px;justify-content:center;margin-top:10px}
  fieldset{border:1px solid #2fa66b;border-radius:10px;padding:10px 14px;min-width:220px;background:rgba(255,255,255,0.04)}
  legend{font-size:14px;color:#aef;font-weight:600;padding:0 6px}
  label{display:block;font-size:13px;margin:8px 0;display:flex;justify-content:space-between;align-items:center}
  label span.value{font-weight:700;color:#ffd54f;min-width:50px;text-align:right}
  input[type=range]{width:140px;margin:0 8px}
  input[type=checkbox]{margin-right:8px}
  .legend{margin-top:10px;color:#eaf5ff;background:rgba(0,0,0,0.12);padding:8px 12px;border-radius:8px;font-size:13px;text-align:center}
  .hint{margin-top:6px;color:#cfe7ff;font-size:13px;text-align:center}
  #shotCount{position:absolute;top:16px;right:40px;font-size:22px;font-weight:700;color:#fffaaf;text-shadow:0 0 6px #000}
</style>
</head>
<body>
  <h1>Tennis Rally Trainer — Final Fixes</h1>
  <div id="wrap">
    <div id="shotCount">Shots: 0</div>
    <canvas id="cv" width="1000" height="700"></canvas>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" class="stop">Stop</button>
    </div>

    <div class="panel">
      <fieldset>
        <legend>Zone Visibility</legend>
        <label><input type="checkbox" id="showOpp" checked> Opponent Zones</label>
        <label><input type="checkbox" id="showPlayer" checked> Player Zones</label>
      </fieldset>

      <fieldset>
        <legend>Ball Speed (seconds)</legend>
        <label>Short: <input type="range" id="shortDur" min="0.8" max="2.5" step="0.1" value="2.0"><span class="value" id="shortDurVal">2.0s</span></label>
        <label>Center: <input type="range" id="centerDur" min="1.0" max="3.0" step="0.1" value="2.5"><span class="value" id="centerDurVal">2.5s</span></label>
        <label>Deep: <input type="range" id="deepDur" min="1.2" max="4.0" step="0.1" value="3.0"><span class="value" id="deepDurVal">3.0s</span></label>
      </fieldset>

      <fieldset>
        <legend>Ball Arc Height (pixels)</legend>
        <label>Short: <input type="range" id="shortArc" min="40" max="140" step="5" value="30"><span class="value" id="shortArcVal">30px</span></label>
        <label>Center: <input type="range" id="centerArc" min="60" max="180" step="5" value="100"><span class="value" id="centerArcVal">100px</span></label>
        <label>Deep: <input type="range" id="deepArc" min="80" max="220" step="5" value="200"><span class="value" id="deepArcVal">200px</span></label>
      </fieldset>

      <fieldset>
        <button id="resetCfg" style="width:100%;margin-top:12px;background:#1f7cae;">Reset Configuration</button>
      </fieldset>
    </div>

    <div class="legend">
      Keys during incoming: <b>Q</b>=LeftShort &nbsp; <b>A</b>=LeftSide &nbsp; <b>Z</b>=LeftDeep &nbsp;
      <b>S</b>=Center (default) &nbsp; <b>E</b>=RightShort &nbsp; <b>D</b>=RightSide &nbsp; <b>C</b>=RightDeep
    </div>
    <div class="hint">Flash shows which zone on your side the opponent will target. Press keys while ball is incoming.</div>
  </div>

<script>
/* Final stable script with bounce at 65% progress */

const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const shotCountEl = document.getElementById('shotCount');

// Audio
const AC = new (window.AudioContext || window.webkitAudioContext)();
function beep(f=700,d=0.06,v=0.07){ try{ const o = AC.createOscillator(), g = AC.createGain(); o.type='sine'; o.frequency.value=f; g.gain.value=v; o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime+d); } catch(e){} }
function playHit(){ beep(880,0.05,0.08); }
function playBounce(){ beep(360,0.04,0.06); }

// projection
function project(xPct,yPct){
  const topW = 0.68, botW = 0.95;
  const t = yPct / 100;
  const wf = topW*(1-t) + botW*t;
  const offsetX = (1 - wf)/2;
  const x = (offsetX + (xPct/100)*wf) * W;
  const y = 30 + t * (H - 60);
  return { x, y, z: wf };
}

// geometry
const topBaselinePct = 8, bottomBaselinePct = 92;
const baselineToServicePct = (18/78)*100;
const topServicePct = topBaselinePct + baselineToServicePct;
const bottomServicePct = bottomBaselinePct - baselineToServicePct;
const netPct = 50;
const originOffsetPct = (2/78)*100;
const playerOriginY = bottomBaselinePct + originOffsetPct;
const oppOriginY = topBaselinePct - originOffsetPct;

// zones
const playerZones = [
  {key:'Q', id:'LeftShort', x:36, y:playerOriginY-8, type:'short'},
  {key:'A', id:'LeftSide',  x:36, y:playerOriginY,   type:'center'},
  {key:'Z', id:'LeftDeep',  x:36, y:playerOriginY+4, type:'deep'},
  {key:'S', id:'Center',    x:50, y:playerOriginY,   type:'center'},
  {key:'E', id:'RightShort',x:64, y:playerOriginY-8, type:'short'},
  {key:'D', id:'RightSide', x:64, y:playerOriginY,   type:'center'},
  {key:'C', id:'RightDeep', x:64, y:playerOriginY+4, type:'deep'}
];
const opponentZones = [
  {id:'LeftShort', x:36, y:oppOriginY+8, type:'short'},
  {id:'LeftSide',  x:36, y:oppOriginY,   type:'center'},
  {id:'LeftDeep',  x:36, y:oppOriginY-4, type:'deep'},
  {id:'Center',    x:50, y:oppOriginY,   type:'center'},
  {id:'RightShort',x:64, y:oppOriginY+8, type:'short'},
  {id:'RightSide', x:64, y:oppOriginY,   type:'center'},
  {id:'RightDeep', x:64, y:oppOriginY-4, type:'deep'}
];

// config (in seconds for duration)
const cfg = {
  shortDur: 2000, centerDur: 2500, deepDur: 3000,
  shortArc: 30, centerArc: 100, deepArc: 200,
  showOpp: true, showPlayer: true
};

// wire UI with value display
function setupSlider(id, unit, converter = x => x) {
  const slider = document.getElementById(id);
  const valEl = document.getElementById(id + 'Val');
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    cfg[id] = converter(val);
    valEl.textContent = val + unit;
  });
}

setupSlider('shortDur', 's', x => x * 1000);
setupSlider('centerDur', 's', x => x * 1000);
setupSlider('deepDur', 's', x => x * 1000);
setupSlider('shortArc', 'px', x => x);
setupSlider('centerArc', 'px', x => x);
setupSlider('deepArc', 'px', x => x);

const showOppEl = document.getElementById('showOpp');
const showPlayerEl = document.getElementById('showPlayer');
showOppEl.addEventListener('change', ()=> cfg.showOpp = showOppEl.checked);
showPlayerEl.addEventListener('change', ()=> cfg.showPlayer = showPlayerEl.checked);

// Reset button
document.getElementById('resetCfg').addEventListener('click', ()=>{
  cfg.shortDur = 2000; cfg.centerDur = 2500; cfg.deepDur = 3000;
  cfg.shortArc = 30; cfg.centerArc = 100; cfg.deepArc = 200;
  cfg.showOpp = cfg.showPlayer = true;
  
  document.getElementById('shortDur').value = 2.0;
  document.getElementById('shortDurVal').textContent = '2.0s';
  document.getElementById('centerDur').value = 2.5;
  document.getElementById('centerDurVal').textContent = '2.5s';
  document.getElementById('deepDur').value = 3.0;
  document.getElementById('deepDurVal').textContent = '3.0s';
  
  document.getElementById('shortArc').value = 30;
  document.getElementById('shortArcVal').textContent = '30px';
  document.getElementById('centerArc').value = 100;
  document.getElementById('centerArcVal').textContent = '100px';
  document.getElementById('deepArc').value = 200;
  document.getElementById('deepArcVal').textContent = '200px';
  
  showOppEl.checked = true;
  showPlayerEl.checked = true;
});

// helpers
function typeForId(id){
  if(!id) return 'center';
  id = id.toLowerCase();
  if(id.includes('short')) return 'short';
  if(id.includes('deep')) return 'deep';
  return 'center';
}
function propsForType(t){
  if(t === 'short') return { dur: cfg.shortDur, arc: cfg.shortArc };
  if(t === 'deep') return { dur: cfg.deepDur, arc: cfg.deepArc };
  return { dur: cfg.centerDur, arc: cfg.centerArc };
}
function findOpp(id){ return opponentZones.find(z=>z.id === id) || opponentZones[3]; }

// state
let leg = {
  src: { xPct: 50, yPct: oppOriginY - 2 },
  dst: { xPct: 50, yPct: playerOriginY },
  start: 0,
  duration: cfg.centerDur,
  arc: cfg.centerArc,
  phase: 'toPlayer',
  bouncePlayed: false
};
let running = false, animReq = null, playerChoice = null;
let flash = { active: false, text: '', color: '#fff', x:0, y:0, start:0 };
let shotCount = 0;

function drawCourt(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#2fa34f'; ctx.fillRect(0,0,W,H);

  const tl = project(6,0), tr = project(94,0), br = project(94,100), bl = project(6,100);
  ctx.save(); ctx.beginPath(); ctx.moveTo(tl.x,tl.y); ctx.lineTo(tr.x,tr.y); ctx.lineTo(br.x,br.y); ctx.lineTo(bl.x,bl.y); ctx.closePath(); ctx.clip();

  const g = ctx.createLinearGradient(0, tl.y, 0, bl.y); g.addColorStop(0,'#2b78a5'); g.addColorStop(1,'#1f5f8b');
  ctx.fillStyle = g; ctx.fillRect(0, tl.y, W, bl.y - tl.y);

  ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
  const tBL = project(10, topBaselinePct), tBR = project(90, topBaselinePct);
  const bBL = project(10, bottomBaselinePct), bBR = project(90, bottomBaselinePct);
  ctx.beginPath(); ctx.moveTo(tBL.x,tBL.y); ctx.lineTo(tBR.x,tBR.y); ctx.moveTo(bBL.x,bBL.y); ctx.lineTo(bBR.x,bBR.y); ctx.stroke();

  ctx.lineWidth = 2;
  const dL_T = project(10, topBaselinePct), dL_B = project(10, bottomBaselinePct);
  const dR_T = project(90, topBaselinePct), dR_B = project(90, bottomBaselinePct);
  ctx.beginPath(); ctx.moveTo(dL_T.x,dL_T.y); ctx.lineTo(dL_B.x,dL_B.y); ctx.moveTo(dR_T.x,dR_T.y); ctx.lineTo(dR_B.x,dR_B.y); ctx.stroke();

  const sL_T = project(23, topBaselinePct), sL_B = project(23, bottomBaselinePct);
  const sR_T = project(77, topBaselinePct), sR_B = project(77, bottomBaselinePct);
  ctx.beginPath(); ctx.moveTo(sL_T.x,sL_T.y); ctx.lineTo(sL_B.x,sL_B.y); ctx.moveTo(sR_T.x,sR_T.y); ctx.lineTo(sR_B.x,sR_B.y); ctx.stroke();

  const tsL = project(23, topServicePct), tsR = project(77, topServicePct);
  const bsL = project(23, bottomServicePct), bsR = project(77, bottomServicePct);
  ctx.beginPath(); ctx.moveTo(tsL.x,tsL.y); ctx.lineTo(tsR.x,tsR.y); ctx.moveTo(bsL.x,bsL.y); ctx.lineTo(bsR.x,bsR.y); ctx.stroke();

  const netCenter = project(50, netPct);
  const topSC = project(50, topServicePct), botSC = project(50, bottomServicePct);
  ctx.beginPath(); ctx.moveTo(topSC.x,topSC.y); ctx.lineTo(netCenter.x, netCenter.y); ctx.lineTo(botSC.x, botSC.y); ctx.stroke();

  ctx.setLineDash([8,5]); ctx.lineWidth = 3;
  const nL = project(10, netPct), nR = project(90, netPct);
  ctx.beginPath(); ctx.moveTo(nL.x,nL.y); ctx.lineTo(nR.x,nR.y); ctx.stroke(); ctx.setLineDash([]);
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(nL.x, nL.y, 4, 0, Math.PI*2); ctx.arc(nR.x, nR.y, 4, 0, Math.PI*2); ctx.fill();

  if (cfg.showOpp) {
    opponentZones.forEach(z => {
      const p = project(z.x, z.y);
      const wBox = 66 * p.z, hBox = 40 * p.z;
      ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
      ctx.strokeRect(p.x - wBox/2, p.y - hBox/2, wBox, hBox);
      ctx.setLineDash([]); ctx.fillStyle = '#fff'; ctx.font = `${11 * p.z}px sans-serif`; ctx.textAlign = 'center';
      ctx.fillText('O-'+z.id, p.x, p.y + 4 * p.z);
      ctx.restore();
    });
  }

  if (cfg.showPlayer) {
    playerZones.forEach(z => {
      const p = project(z.x, z.y);
      const wBox = 66 * p.z, hBox = 40 * p.z;
      ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
      ctx.strokeRect(p.x - wBox/2, p.y - hBox/2, wBox, hBox);
      ctx.setLineDash([]); ctx.fillStyle = '#fff'; ctx.font = `${11 * p.z}px sans-serif`; ctx.textAlign = 'center';
      ctx.fillText(z.id, p.x, p.y + 4 * p.z);
      ctx.restore();
    });
  }

  ctx.restore();
}

function drawRacket2D(x, y, angle = 0, scale = 1, color = '#ffd966'){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.scale(scale, scale);
  ctx.fillStyle = '#5a3a1a'; ctx.fillRect(-6, 6, 4, 28);
  ctx.beginPath(); ctx.ellipse(0, -26, 18, 26, 0, 0, Math.PI*2);
  ctx.fillStyle = color; ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth = 1;
  for(let i=-8;i<=8;i+=4){ ctx.beginPath(); ctx.moveTo(i,-40); ctx.lineTo(i,-14); ctx.stroke(); }
  ctx.restore();
}

// Ball trajectory with bounce at 65%
function drawFrame(progress){
  const eased = progress < 0.5 ? 2*progress*progress : 1 - Math.pow(-2*progress+2,2)/2;
  const xPct = leg.src.xPct + (leg.dst.xPct - leg.src.xPct) * eased;
  const yPct = leg.src.yPct + (leg.dst.yPct - leg.src.yPct) * eased;
  
  // Two-arc trajectory with bounce at 65%
  let zPx;
  const BOUNCE_POINT = 0.65;
  if (progress < BOUNCE_POINT) {
    // First arc: 0 -> bounce point
    const p1 = progress / BOUNCE_POINT;
    zPx = Math.sin(Math.PI * p1) * leg.arc;
  } else {
    // Second arc after bounce: bounce point -> 1
    const p2 = (progress - BOUNCE_POINT) / (1 - BOUNCE_POINT);
    zPx = Math.sin(Math.PI * p2) * (leg.arc * 0.5); // Lower bounce
  }
  
  const p = project(xPct, yPct);
  const drawX = p.x, drawY = p.y - zPx;

  // shadow
  ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.32)'; ctx.beginPath(); 
  ctx.ellipse(drawX, p.y + 6, Math.max(8, 26*p.z - zPx*0.06), Math.max(4, 10*p.z - zPx*0.1), 0, 0, Math.PI*2); 
  ctx.fill(); ctx.restore();

  // ball
  const r = Math.max(6, 8 * (1 + (1 - p.z) * 0.4));
  const grad = ctx.createRadialGradient(drawX - r*0.25, drawY - r*0.25, 1, drawX, drawY, r);
  grad.addColorStop(0,'#fff9a8'); grad.addColorStop(0.6,'#ffd600'); grad.addColorStop(1,'#c99b00');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(drawX, drawY, r, 0, Math.PI*2); ctx.fill();

  // Show bounce indicator at bounce point
  if (progress >= BOUNCE_POINT - 0.02 && progress <= BOUNCE_POINT + 0.02) {
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(drawX, p.y + 2, 18, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  const oppContact = project(leg.src.xPct, leg.src.yPct);
  const plContact  = project(leg.dst.xPct, leg.dst.yPct);

  let oppAngle = 0, plAngle = 0;
  if (leg.phase === 'toPlayer') {
    const s = Math.min(1, Math.max(0, (progress - 0.6)/0.4));
    oppAngle = -0.9 * Math.sin(s * Math.PI);
  } else {
    const s = Math.min(1, Math.max(0, (progress - 0.6)/0.4));
    plAngle = 0.9 * Math.sin(s * Math.PI);
  }

  drawRacket2D(oppContact.x, oppContact.y, oppAngle, 0.95, '#ff7a7a');
  drawRacket2D(plContact.x, plContact.y, plAngle, 1.05, '#7ab7ff');
}

const FLASH_MS = 400;

function loop(){
  if(!running) return;
  const now = performance.now();
  const elapsed = now - leg.start;
  const progress = Math.min(1, elapsed / leg.duration);

  // bounce sound at 65%
  if(!leg.bouncePlayed && progress >= 0.65){ 
    playBounce(); 
    leg.bouncePlayed = true; 
  }

  drawCourt();

  if(flash.active){
    const alpha = 1 - Math.min(1, (now - flash.start) / FLASH_MS);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(flash.text, flash.x, flash.y + 36);
    ctx.restore();
  }

  drawFrame(progress);

  if(progress >= 1){
    playHit(); shotCount++; shotCountEl.textContent = 'Shots: ' + shotCount;

    if(leg.phase === 'toPlayer'){
      const key = playerChoice ? playerChoice.toUpperCase() : 'S';
      const map = {'Q':'LeftShort','A':'LeftSide','Z':'LeftDeep','S':'Center','E':'RightShort','D':'RightSide','C':'RightDeep'};
      const targetId = map[key] || 'Center';
      const oppZ = findOpp(targetId);
      const ttype = typeForId(oppZ.id);
      const props = propsForType(ttype);

      leg = {
        src: { xPct: leg.dst.xPct, yPct: leg.dst.yPct },
        dst: { xPct: oppZ.x, yPct: oppZ.y },
        start: now + 120,
        duration: props.dur,
        arc: props.arc,
        phase: 'toOpponent',
        bouncePlayed: false
      };

      playerChoice = null;
      flash.active = false;

    } else {
      const tz = playerZones[Math.floor(Math.random() * playerZones.length)];
      const ttype = typeForId(tz.id);
      const props = propsForType(ttype);

      const pPos = project(tz.x, tz.y);
      flash = { active: true, text: tz.id, color: '#fff', x: pPos.x, y: pPos.y, start: now };

      leg = {
        src: { xPct: leg.dst.xPct, yPct: leg.dst.yPct },
        dst: { xPct: tz.x, yPct: tz.y },
        start: now + 220,
        duration: props.dur,
        arc: props.arc,
        phase: 'toPlayer',
        bouncePlayed: false
      };
    }
  }

  animReq = requestAnimationFrame(loop);
}

document.addEventListener('keydown', (e) => {
  if(!running) return;
  const k = e.key.toUpperCase();
  if(leg.phase === 'toPlayer' && ['Q','A','Z','S','E','D','C'].includes(k)){
    playerChoice = k;
  }
});

document.getElementById('startBtn').addEventListener('click', () => {
  if(AC.state === 'suspended') AC.resume();
  if(running) return;
  running = true;
  shotCount = 0; shotCountEl.textContent = 'Shots: 0';

  const tz = playerZones[Math.floor(Math.random() * playerZones.length)];
  const props = propsForType(typeForId(tz.id));
  leg = {
    src: { xPct: 50, yPct: oppOriginY - 2 },
    dst: { xPct: tz.x, yPct: tz.y },
    start: performance.now(),
    duration: props.dur,
    arc: props.arc,
    phase: 'toPlayer',
    bouncePlayed: false
  };
  playerChoice = null;
  flash.active = false;
  animReq = requestAnimationFrame(loop);
});

document.getElementById('stopBtn').addEventListener('click', () => {
  running = false;
  if(animReq) cancelAnimationFrame(animReq);
});

drawCourt();
</script>
</body>
</html>
